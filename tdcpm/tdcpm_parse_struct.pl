#!/usr/bin/perl

# This file is part of TDCPM - time dependent calibration parameters.
#
# Copyright (C) 2017  Haakan T. Johansson  <f96hajo@chalmers.se>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301  USA

use strict;
use warnings;

########################################################################
# Subroutines

sub find_structure_items();
sub create_struct_items_decl($$);
sub create_struct_items($$);
sub create_struct_items_void($$);

########################################################################

my $struct = (); # Name of the structure, without ..._t
my $header = 0;

foreach my $arg (@ARGV)
{
    if($arg =~ /^--struct=([a-zA-Z0-9_]+)$/)
    {
	$struct = $1;
    }
    elsif($arg =~ /^--header$/)
    {
	$header = 1;
    }
    else
    {
	die "Unhandled argument: $arg";
    }
}

# if (!$struct) { die "Structure name not specified"; }

########################################################################
# Read the input

my $fullinput = do { local $/; <STDIN> };

# Strip comments, well, simple ones.  Comment markers in strings
# will trip it over, but ... do not run this on such code then!

$fullinput =~ s,/\*.*?\*/,,sg;
$fullinput =~ s,//.*,,g;

# Remove preprocessor directives

$fullinput =~ s,#.*,,g;

# Turn the input into one long line.  Simplifies further parsing.

$fullinput =~ s,\n, ,sg;

# print $fullinput;

########################################################################
# Find all structures.

my %structs = ();

find_structure_items();

########################################################################

my $define_name = "__GEN_"."STRUCT"."_ITEMS_H__";

print <<"EndOfText";
/***********************************************************************
 *
 * This file is autogenerated by $0
 *
 * Editing is useless.
 *
 **********************************************************************/

/* The headers declaring '...' (TODO: insert structure names!)
 * must be included before this file!
 */

EndOfText

if ($header) { print <<"EndOfText";
\#ifndef $define_name
\#define $define_name

\#include <stddef.h>

EndOfText
} else { print <<"EndOfText";
\#include "tdcpm_struct_info.h"

EndOfText
}

print <<"EndOfText";
/**********************************************************************/

void tdcpm_declare_struct()
{
EndOfText

########################################################################

foreach $struct (keys %structs)
{
    create_struct_items_decl($struct, $structs{$struct});
    create_struct_items($struct, $structs{$struct});
    create_struct_items_void($struct, $structs{$struct});
}

########################################################################

print <<"EndOfText";
}

/**********************************************************************/
EndOfText

if ($header) { print <<"EndOfText";

\#endif/*$define_name*/
EndOfText
}

exit 0;

########################################################################

sub find_structure_items()
{
    # TODO: Extract until the ending matched brace, such that
    # (anonymous) substructures can be supported.
    
    while ($fullinput =~ s/(\s|^)TDCPM_STRUCT_DEF(\s+typedef)?\s+struct\s+([_A-Za-z][_A-Za-z0-9]*?)(_t)?\s+{(.*?)}//) {
	my $struct  = $3;
	my $content = $5;
	my @content = split /;|\)\)/,$content;

	my @items = ();

	# print "Found struct $struct:\n";
	
	if ($structs{$struct}) {
	    die "Multiple definitions of structure '$struct'."; }

	foreach my $item (@content)
	{
	    if ($item =~ /^\s*$/) { }
	    elsif ($item =~ /^\s*LWROC_MSG_HEADER\(\(\s*$/) {
	    }
	    elsif ($item =~ /^\s*LWROC_MSG_FOOTER\(\(\s*$/) {
	    }
	    elsif ($item =~ /
    ^\s*                                                   # beginning of line
    ((uint32_t|
      double)                                              # item type
     \s+
    )
    ([_A-Za-z][_A-Za-z0-9]*)                               # item name
    (\s*\[\s*([0-9]+|[_A-Za-z][_A-Za-z0-9]*)
     \]
    )?                                                     # array len
    \s*(TDCPM_UNIT\s*\(\s*\"([^\".]*)\"\s*\)\s*)?
    \s*$                                                   # end of line
    /x)
            {
	        my $type = $1;
	        my $name = $3;
	        my $arraylen = $5;
	        my $unit = $7;

		$type =~ s/const\s*//g;
		$type =~ s/\s//g;

		if (!defined($arraylen)) { $arraylen = 0; }

		# These are leftovers.  We keep the regex in case they
                # become needed.
		if ($arraylen && ($type ne "char" && $type ne "uint32_t")) {
		    die "Non-char arrays not supported: '$item'."; }

		if ($arraylen && $type eq "char" &&
		    $arraylen % 4 != 0) {
		    die "char arrays must have length multiple of 4."; }

		if ($type eq "lwroc_msg_header") {
		    print "/* TODO: remove lwroc_msg_header items... */\n";
		} else {
		    my $typem = $type;
		    $typem =~ s/\*/_ptr/; # mangled name
		    if ($arraylen) {
			$typem .= "_array";
		    }

		    my $rec = {
			TYPE  => $type,
			TYPEM => $typem,
			NAME  => $name,
			ARRAYLEN => $arraylen,
			UNIT  => $unit,
		    };

		    push @items,$rec;
		}
	    }
	    else { die "Malformed item: '$item'."; }
	}

	$structs{$struct} = \@items;
    }
}

########################################################################

sub create_struct_items_decl($$)
{
    my $struct = shift;
    my $items_ref = shift;

    my $hasstrings = 0;

    my $li_struct = "li_$struct";

    print "  tdcpm_struct_info *$li_struct;\n";

    foreach my $item (@$items_ref)
    {
	my $li_item = "li_${struct}_$item->{NAME}";

	print "  tdcpm_struct_info_item *$li_item;\n";
    }
    print "\n";
}

sub create_struct_items($$)
{
    my $struct = shift;
    my $items_ref = shift;

    my $hasstrings = 0;

    my $li_struct = "li_$struct";

    print "  $li_struct = TDCPM_STRUCT($struct, \"$struct\");\n\n";

    foreach my $item (@$items_ref)
    {
	my $uctypem = uc($item->{TYPEM});

	my $li_item = "li_${struct}_$item->{NAME}";

	my $strname = $item->{NAME};
	my $unit = $item->{UNIT};

	$strname =~ s/^_//;
	if (!defined($unit)) { $unit = ""; }

	print "  $li_item = TDCPM_STRUCT_ITEM_$uctypem($li_struct, $struct, $item->{NAME}, \"$strname\", \"$unit\");\n";
    }
    print "\n";
}

sub create_struct_items_void($$)
{
    my $struct = shift;
    my $items_ref = shift;

    my $hasstrings = 0;

    my $li_struct = "li_$struct";

    print "  (void) $li_struct;\n";

    foreach my $item (@$items_ref)
    {
	my $li_item = "li_${struct}_$item->{NAME}";

	print "  (void) $li_item;\n";
    }
    print "\n";
}

########################################################################
