#!/usr/bin/perl

# This file is part of UCESB - a tool for data unpacking and processing.
#
# Copyright (C) 2016  Haakan T. Johansson  <f96hajo@chalmers.se>
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
# MA  02110-1301  USA

use strict;

my $struct = ();

foreach my $arg (@ARGV)
{
    if($arg =~ /^--struct=([a-zA-Z0-9_]+)$/)
    {
	$struct = $1;
    }
    else
    {
	die "Unhandled argument: $arg";
    }
}

if (!$struct) { die "Structure not specified"; }

# Parse the input

my $fullinput = "";

while (my $line = <STDIN>)
{
    chomp $line;
    $line =~ s,//.*,,;
    $line =~ s,/\*.*?\*/,,; # stupid, but kills simple comments
    $fullinput .= $line." ";
}

my $found = 0;

my @items = ();
my %itemsindex = ();
my @ctrlitems = ();
my @ctrlsize = ();

my $numctrlitems = 0;

# We can at the moment not handle non-4-byte members, as they become unaligned

my %retypes = (
    "int"    => "int32_t",
    # "ushort" => "uint32_t",
    "uint"   => "uint32_t");

my %typepun = (
    "float" => "external_write_float_as_uint32");

while ($fullinput =~ s/(\s|^)struct\s+$struct\s+{(.*?)}//) {
    my $content = $2;
    my @content = split /;/,$content;

    if ($found) { die "Multiple definitions of structure '$struct'."; }
    $found = 1;

    foreach my $item (@content)
    {
	if ($item =~ /^\s*$/) { }
	elsif ($item =~ /^\s*(uint32_t|int32_t|float|int|uint)\s+([_A-Za-z][_A-Za-z0-9]*)(\s*\[\s*([0-9]+|[_A-Za-z][_A-Za-z0-9]*)\s*(EXT_STRUCT_CTRL\s*\(\s*([_A-Za-z][_A-Za-z0-9]*)\s*\)\s*)?\])?\s*$/)
	{
	    my $type = $1;
	    my $name = $2;
	    my $arraylen = $4;
	    my $ctrlname = $6;

	    if ($retypes{$type}) { $type = $retypes{$type}; }

	    push @items,"$type $name $arraylen $ctrlname";

	    $itemsindex{$name} = $#items;

	    if ($ctrlname)
	    {
		my $ctrlitemsarray = $ctrlitems[$itemsindex{$ctrlname}];

		if (!$ctrlitemsarray)
		{
		    $ctrlitemsarray = [];
		    $ctrlsize[$itemsindex{$ctrlname}] = $arraylen;
		    $numctrlitems++;
		}
		else
		{
		    if ($ctrlsize[$itemsindex{$ctrlname}] != $arraylen) {
			die "Different length of arrays controlled by '$ctrlname'.";
		    }
		}

		push @$ctrlitemsarray,$#items;

		$ctrlitems[$itemsindex{$ctrlname}] = $ctrlitemsarray;

		my $items = @$ctrlitemsarray;

		# print "// >>$items<<\n";
	    }
	}
	else { die "Malformed item: '$item'."; }

	# print "$item\n"
    }
}

if (!$found) { die "Structure '$struct' not found."; }

# Generate header

my $define_name = "__EXTERNAL_WRITER_".uc($struct)."__";

print <<"EndOfText";
//////////////////////////////////////////////////////////////////////
//
// This file is autogenerated by $0
//
// Editing is useless.
//
//////////////////////////////////////////////////////////////////////

\#ifndef $define_name
\#define $define_name

\#include "external_writer.hh"
\#include <arpa/inet.h>
\#include <stddef.h>

// Wrapper functions for external ntuple/root/struct writing of
// the structure '$struct'.

EndOfText

# Print our idea of the structure

my $numitems = 0;

foreach my $item (@items)
{
    $item =~ /(.*) (.*) (.*) (.*)/;

    my $type = $1;
    my $name = $2;
    my $arraylen = $3;
    my $ctrlname = $4;

    my $printarray = "";
    my $printctrl = "";

    if ($ctrlname) { $printctrl = " EXT_STRUCT_CTRL($ctrlname)"; }
    if ($arraylen) { $printarray = "[$arraylen$printctrl]"; }

    print sprintf ("// %-10s %s$printarray\n",$type,$name);

    if ($arraylen) { $numitems += $arraylen; }
    else { $numitems++; }
}

my %hashtypes = (
    "uint32_t" => "EXTERNAL_WRITER_FLAG_TYPE_UINT32",
    "int32_t" => "EXTERNAL_WRITER_FLAG_TYPE_INT32",
    "float" => "EXTERNAL_WRITER_FLAG_TYPE_FLOAT32");

my %clearzerotypes = (
    "uint32_t" => " | 0x40000000",
    "int32_t" => " | 0x40000000",
    "float" => "");

print <<"EndOfText";

void send_offsets_$struct(external_writer *ew)
{
  ew->send_alloc_array(sizeof($struct));

EndOfText

foreach my $item (@items)
{
    $item =~ /(.*) (.*) (.*) (.*)/;

    my $type = $1;
    my $name = $2;
    my $arraylen = $3;
    my $ctrlname = $4;

    my $printarray = "(uint) -1";
    my $printctrl = "";

    if ($ctrlname) { $printctrl = "$ctrlname"; }
    if ($arraylen) { $printarray = "$arraylen"; }

    my $printtype = $hashtypes{$type};
    my $printname = $name;

    $printname =~ s/^_//;
    $printctrl =~ s/^_//;

    print "  ew->send_hbname_branch(\"DEF\",".
	"offsetof($struct,$name),\n                         ".
	"sizeof(/*$struct.$name*/$type),\n                         ".
	"\"$printname\",$printarray,\"$printctrl\",$printtype);\n"
}

print <<"EndOfText";

  uint32_t offset_msg_size = ($numitems + 2 * $numctrlitems) * (uint32_t) sizeof(uint32_t);
  uint32_t fill_msg_size = (1 + $numitems) * (uint32_t) sizeof(uint32_t);

  ew->set_max_message_size(fill_msg_size > offset_msg_size ?
                           fill_msg_size : offset_msg_size);

  {
    uint32_t *o = ew->prepare_send_offsets(offset_msg_size);

EndOfText

foreach my $item (@items)
{
    $item =~ /(.*) (.*) (.*) (.*)/;

    my $type = $1;
    my $name = $2;
    my $arraylen = $3;
    my $ctrlname = $4;

    if (!$ctrlname)
    {
	if ($arraylen)
	{
	    print "    for (int i = 0; i < $arraylen; i++)\n";
	    print "      *(o++) = htonl((uint32_t) ((offsetof($struct,${name})+i*sizeof($type))$clearzerotypes{$type}));\n";
	}
	else
	{
	    my $ctrlitemsarray = $ctrlitems[$itemsindex{$name}];

	    if ($ctrlitemsarray)
	    {
		my $maxloops = $ctrlsize[$itemsindex{$name}];
		my $loopitems = @$ctrlitemsarray;

		print "    *(o++) = htonl((uint32_t) offsetof($struct,$name) | 0x80000000 | 0x40000000);\n";
		print "    *(o++) = htonl($maxloops);\n";
		print "    *(o++) = htonl($loopitems);\n";

		print "    for (int l = 0; l < $maxloops; l++) {\n";
		foreach my $itemindex (@$ctrlitemsarray) {
		    my $subitem = $items[$itemindex];
		    $subitem =~ /(.*) (.*) (.*) (.*)/;

		    my $subtype = $1;
		    my $subname = $2;

		    print "      *(o++) = htonl((uint32_t) ((offsetof($struct,${subname})+l*sizeof($subtype))$clearzerotypes{$subtype}));\n";
		}
		print "    }\n";
	    }
	    else
	    {
		print "    *(o++) = htonl((uint32_t) offsetof($struct,$name)$clearzerotypes{$type});\n";
	    }
	}
    }
}

print <<"EndOfText";

    ew->send_offsets_fill(o);
  }

  ew->send_setup_done();
}

//////////////////////////////////////////////////////////////////////

void send_fill_x_$struct(external_writer *ew,
                         const $struct &s,
                         uint32_t struct_index = 0,
                         uint32_t ntuple_index = 0)
{
  uint32_t fill_msg_size = (1 + $numitems) * (uint32_t) sizeof(uint32_t);

  uint32_t *p = ew->prepare_send_fill_x(fill_msg_size,
					struct_index,ntuple_index);

  *(p++) = htonl(0x40000000); // marker that we are not compacted

EndOfText

foreach my $item (@items)
{
    $item =~ /(.*) (.*) (.*) (.*)/;

    my $type = $1;
    my $name = $2;
    my $arraylen = $3;
    my $ctrlname = $4;

    if (!$ctrlname)
    {
	if ($arraylen)
	{
	    my $typepun = $typepun{$type};
	    if (!$typepun) { $typepun = ""; }

	    print "  for (int i = 0; i < $arraylen; i++)\n";
	    print "    *(p++) = htonl($typepun(s.${name}[i]));\n";
	}
	else
	{
	    my $ctrlitemsarray = $ctrlitems[$itemsindex{$name}];

	    if ($ctrlitemsarray)
	    {
		my $maxloops = $ctrlsize[$itemsindex{$name}];
		my $loopitems = @$ctrlitemsarray;

		my $loopclamped = "loop_n_$name";

		print "  {\n";
		print "    uint32_t $loopclamped = s.$name;\n";
		print "    assert ($loopclamped <= $maxloops);\n";

		print "    *(p++) = htonl($loopclamped);\n";

		print "    for (int l = 0; l < $loopclamped; l++) {\n";
		foreach my $itemindex (@$ctrlitemsarray) {
		    my $subitem = $items[$itemindex];
		    $subitem =~ /(.*) (.*) (.*) (.*)/;

		    my $subtype = $1;
		    my $subname = $2;

		    my $typepun = $typepun{$subtype};
		    if (!$typepun) { $typepun = ""; }

		    print "      *(p++) = htonl($typepun(s.${subname}[l]));\n";
		}
		print "    }\n";
		print "  }\n";
	    }
	    else
	    {
		my $typepun = $typepun{$type};
		if (!$typepun) { $typepun = ""; }

		print "  *(p++) = htonl($typepun(s.$name));\n";
	    }
	}
    }
}

print <<"EndOfText";

  ew->send_offsets_fill(p);
}
EndOfText

# Generate footer

print <<"EndOfText";

//////////////////////////////////////////////////////////////////////

\#endif\/\/ $define_name

EndOfText
